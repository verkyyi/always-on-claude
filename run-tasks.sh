#!/bin/bash
# run-tasks.sh — Execute tasks defined in tasks.txt
# Generated by /plan-overnight. Run inside a tmux session:
#
#   tmux new -s overnight
#   bash ~/dev-env/run-tasks.sh [tasks.txt]
#   # Detach: Ctrl+A, then D

TASKS_FILE="${1:-$HOME/tasks.txt}"
LOG_DIR="${LOG_DIR:-$HOME/logs}"
mkdir -p "$LOG_DIR"

# Derive log filename from tasks file (e.g. ~/tasks-ainbox.txt → ~/logs/overnight-ainbox-20260218-2300.md)
TASKS_BASENAME=$(basename "$TASKS_FILE" .txt)           # tasks-ainbox
PROJECT_SLUG="${TASKS_BASENAME#tasks-}"                 # ainbox (strip "tasks-" prefix)
LOG_FILE="$LOG_DIR/overnight-${PROJECT_SLUG}-$(date +%Y%m%d-%H%M).md"

DEFAULT_DIR="$(pwd)"

if [[ ! -f "$TASKS_FILE" ]]; then
  echo "Error: tasks file not found: $TASKS_FILE"
  echo "Run /plan-overnight inside Claude Code to generate one."
  exit 1
fi

# Load secrets from SSM Parameter Store (safe to skip if not configured)
source ~/dev-env/load-secrets.sh 2>/dev/null || true

echo "# Overnight Run — $(date)" > "$LOG_FILE"
echo "Tasks file: \`$TASKS_FILE\`" >> "$LOG_FILE"
echo "" >> "$LOG_FILE"

task_num=0
desc=""
timeout_val=600
dir="$DEFAULT_DIR"
prompt=""
in_prompt=false

run_task() {
  local num=$1 desc=$2 timeout_val=$3 dir=$4 prompt=$5

  echo "## Task $num: $desc" >> "$LOG_FILE"
  echo "Dir: \`$dir\` | Timeout: ${timeout_val}s | Started: $(date)" >> "$LOG_FILE"
  echo "" >> "$LOG_FILE"

  local start_commit
  start_commit=$(git -C "$dir" rev-parse HEAD 2>/dev/null || echo "")

  if (cd "$dir" && timeout "$timeout_val" claude -p "$prompt" --dangerously-skip-permissions 2>&1 | tail -50 >> "$LOG_FILE"); then
    echo "" >> "$LOG_FILE"
    echo "**Status: Completed**" >> "$LOG_FILE"
  else
    echo "" >> "$LOG_FILE"
    echo "**Status: Failed or timed out**" >> "$LOG_FILE"
  fi

  if [[ -n "$start_commit" ]]; then
    echo "" >> "$LOG_FILE"
    echo "Commits:" >> "$LOG_FILE"
    echo '```' >> "$LOG_FILE"
    git -C "$dir" log --oneline "$start_commit"..HEAD 2>/dev/null >> "$LOG_FILE"
    echo '```' >> "$LOG_FILE"
  fi

  echo "" >> "$LOG_FILE"
}

process_task() {
  [[ -z "$desc" ]] && return
  (( task_num++ ))
  run_task "$task_num" "$desc" "$timeout_val" "${dir:-$DEFAULT_DIR}" "$prompt"
  desc=""
  timeout_val=600
  dir="$DEFAULT_DIR"
  prompt=""
  in_prompt=false
}

while IFS= read -r line || [[ -n "$line" ]]; do
  # Skip comment lines
  [[ "$line" =~ ^#.*$ ]] && { in_prompt=false; continue; }

  # Task separator
  if [[ "$line" == "---" ]]; then
    process_task
    continue
  fi

  # Key: value fields
  if [[ "$line" =~ ^desc:\ (.*) ]]; then
    desc="${BASH_REMATCH[1]}"
    in_prompt=false
  elif [[ "$line" =~ ^timeout:\ (.*) ]]; then
    timeout_val="${BASH_REMATCH[1]}"
    in_prompt=false
  elif [[ "$line" =~ ^dir:\ (.*) ]]; then
    dir="${BASH_REMATCH[1]}"
    in_prompt=false
  elif [[ "$line" =~ ^prompt:\ (.*) ]]; then
    prompt="${BASH_REMATCH[1]}"
    in_prompt=true
  elif [[ "$in_prompt" == true && "$line" =~ ^[[:space:]]+(.*) ]]; then
    # Continuation of multi-line prompt (indented lines)
    prompt="$prompt ${BASH_REMATCH[1]}"
  else
    in_prompt=false
  fi
done < "$TASKS_FILE"

# Process the final task
process_task

echo "## Run Complete" >> "$LOG_FILE"
echo "Finished: $(date)" >> "$LOG_FILE"

echo ""
echo "Done! Log written to: $LOG_FILE"
